<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Endless Tetris</title>
  <style>
    :root {
      --tetris-cyan: #00f0f0;
      --bg-dark: #1a1b1c;
      --panel: rgba(255,255,255,0.04);
    }
    * { box-sizing: border-box; }
    body {
      transform: scale(0.73); 
      transform-origin: top left; 
      width: calc(100% / 0.73); 
      height: calc(100% / 0.73); 
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      background: var(--bg-dark);
      color: #E1E1E1;
      font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .game-container { display: flex; gap: 20px; align-items: flex-start; }
    .side-container { display: flex; flex-direction: column; gap: 20px; }
    .preview-container, .hold-container { display: flex; flex-direction: column; align-items: center; }
    .preview-label, .hold-label { color: var(--tetris-cyan); margin-bottom: 10px; font-size: 18px; }
    canvas {
      border: 4px solid var(--tetris-cyan);
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,240,240,0.2);
      background: #000;
      image-rendering: pixelated;
    }
    #stats {
      display: flex;
      gap: 20px;
      font-size: 20px;
      color: var(--tetris-cyan);
      margin: 20px 0;
    }
    #controls-panel {
      background: var(--panel);
      padding: 1rem;
      border-radius: 8px;
      margin-top: 20px;
      width: 560px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      position: relative;
    }
    .buttons-row { display: flex; gap: 8px; }
    .btn-wrap { position: relative; display: inline-block; }
    button.control-btn {
      padding: 10px 14px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
      background: transparent;
      color: #E1E1E1;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
    }
    .no-select { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    button.control-btn:active { transform: translateY(1px); }
    .hi-container {
      margin-top: 8px;
      width: 100px;
      text-align: center;
      color: #dfeff0;
      font-size: 13px;
      line-height: 1.2;
      background: rgba(255,255,255,0.02);
      border-radius: 6px;
      padding: 6px;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .hi-title { color: var(--tetris-cyan); font-weight: 700; margin-bottom: 4px; font-size: 13px; }
    .hi-row { display: flex; justify-content: space-between; gap: 6px; font-size: 12px; }
    .hi-label { color: #9ec; flex: 1; text-align: left; }
    .hi-value { color: #fff; flex: 1; text-align: right; font-weight: 700; }
    .hi-actions { margin-top: 6px; display: flex; gap: 6px; justify-content: center; }
    .hi-actions button {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      padding: 4px 6px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      color: #dfeff0;
    }
    .btn-label-canvas {
      display: inline-block;
      vertical-align: middle;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
    }
    .combo-btb-container {
      margin-top: 8px;
      width: 100px;
      text-align: left;
      color: #dfeff0;
      font-size: 13px;
      line-height: 1.2;
      background: rgba(255,255,255,0.02);
      border-radius: 6px;
      padding: 6px;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .combo-btb-title { color: var(--tetris-cyan); font-weight: 700; margin-bottom: 6px; font-size: 13px; text-align: center; }
    .combo-row { display: flex; justify-content: space-between; gap: 6px; font-size: 12px; margin-bottom: 4px; }
    .combo-label { color: #9ec; }
    .combo-value { color: #fff; font-weight: 700; }
  </style>
</head>
<body>
  <div id="stats">
    <div id="score">Score: 0</div>
    <div id="level">Level: 1</div>
  </div>
  <div class="game-container">
    <div class="hold-container">
      <div class="hold-label">Hold:</div>
      <canvas id="hold" width="100" height="100"></canvas>
      <div id="hi-container" class="hi-container" aria-live="polite">
        <div class="hi-title">Hi Records</div>
        <div class="hi-row"><div class="hi-label">盖世战绩</div><div id="hi-score" class="hi-value">0</div></div>
        <div class="hi-row"><div class="hi-label">闯关巅峰</div><div id="hi-level" class="hi-value">1</div></div>
        <div class="hi-row"><div class="hi-label">连斩绝响</div><div id="hi-combo" class="hi-value">0</div></div>
        <div class="hi-row"><div class="hi-label">背水雄威</div><div id="hi-btb" class="hi-value">0</div></div>
        <div class="hi-row"><div class="hi-label">一扫而空</div><div id="hi-pc" class="hi-value">0</div></div>
        <div class="hi-actions"><button id="hi-reset" class="no-select">Reset</button></div>
      </div>
      <div id="combo-btb" class="combo-btb-container" aria-live="polite">
        <div class="combo-btb-title">Chains</div>
        <div class="combo-row"><div class="combo-label">手起刀落</div><div id="combo-value" class="combo-value">0</div></div>
        <div class="combo-row"><div class="combo-label">背城借一</div><div id="btb-value" class="combo-value">0</div></div>
      </div>
    </div>
    <canvas id="tetris" width="240" height="560"></canvas>
    <div class="side-container">
      <div class="preview-container">
        <div class="preview-label">Next:</div>
        <canvas id="preview" width="100" height="100"></canvas>
      </div>
    </div>
  </div>
  <div id="controls-panel">
    <div class="buttons-row">
      <div class="btn-wrap"><button id="btn-hold" class="control-btn no-select" aria-label="Hold"></button></div>
    </div>
    <div class="buttons-row">
      <div class="btn-wrap"><button id="btn-rot-ccw" class="control-btn no-select" aria-label="Rotate ↺ (CCW)"></button></div>
      <div class="btn-wrap"><button id="btn-rot-cw" class="control-btn no-select" aria-label="Rotate ↻ (CW)"></button></div>    </div>
    <div class="buttons-row">
      <div class="btn-wrap"><button id="btn-left" class="control-btn no-select" aria-label="← Left"></button></div>
      <div class="btn-wrap"><button id="btn-right" class="control-btn no-select" aria-label="Right →"></button></div>
    </div>
    <div class="buttons-row">
      <div class="btn-wrap"><button id="btn-soft" class="control-btn no-select" aria-label="Soft Drop"></button></div>
      <div class="btn-wrap"><button id="btn-hard" class="control-btn no-select" aria-label="Hard Drop"></button></div>
    <br>
    </div>
  </div>
<script>
  (() => {
  const CONFIG = {
    BLOCK_SIZE: 24,
    REFRESH_TIMER: 3000,
    SFX_VOLUME: 1.5,
    SFX_DURATION: 0.300,
    INITIAL_DELAY: 150,
    INTERVAL_DELAY: 40,
    LOCK_DELAY_MS: 10000,
    LEVEL_UP_FACTOR: 50,
    ANIM_BUCKETS: 80,
    ANIM_CYCLE_MS: 2000,
    ANIM_GHOST_ALPHA: 0.50,
    ANIM_DYNAMIC_CACHE_LIMIT: 32,
    PREVIEW_COUNT: 5,
    PC_FLASH_CYCLE_MS: 200,
    TSPIN_FLASH_CYCLE_MS: 100,
    TSPIN_FLASH_DURATION_MS: 10000
  };

  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');
  const previewCanvas = document.getElementById('preview');
  const previewCtx = previewCanvas.getContext('2d');
  const holdCanvas = document.getElementById('hold');
  const holdCtx = holdCanvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const hiScoreEl = document.getElementById('hi-score');
  const hiLevelEl = document.getElementById('hi-level');
  const hiComboEl = document.getElementById('hi-combo');
  const hiBtbEl = document.getElementById('hi-btb');
  const hiPcEl = document.getElementById('hi-pc');
  const hiResetBtn = document.getElementById('hi-reset');
  const comboValueEl = document.getElementById('combo-value');
  const btbValueEl = document.getElementById('btb-value');

  const STORAGE_KEY_SCORE = 'tetris_hi_score_v1';
  const STORAGE_KEY_LEVEL = 'tetris_hi_level_v1';
  const STORAGE_KEY_COMBO = 'tetris_hi_combo_v1';
  const STORAGE_KEY_BTB = 'tetris_hi_btb_v1';
  const STORAGE_KEY_PC = 'tetris_hi_pc_v1';

  const COLORS = ['#00FFFF', '#FFFF00', '#B000B0', '#FFA500', '#0000FF', '#00FF00', '#FF0000'];

  class AnimationColorCache {
    constructor({ buckets = CONFIG.ANIM_BUCKETS, cycleMs = CONFIG.ANIM_CYCLE_MS, ghostAlpha = CONFIG.ANIM_GHOST_ALPHA, dynamicLimit = CONFIG.ANIM_DYNAMIC_CACHE_LIMIT } = {}) {
      this.buckets = buckets;
      this.cycleMs = cycleMs;
      this.ghostAlpha = ghostAlpha;
      this.dynamicLimit = dynamicLimit;
      this._map = new Map(); 
    }

    _hexToRgbObj(hex) {
      const h = (hex || '#000000').replace('#', '');
      return {
        r: parseInt(h.substring(0, 2), 16),
        g: parseInt(h.substring(2, 4), 16),
        b: parseInt(h.substring(4, 6), 16)
      };
    }

    _rgbToHex(r, g, b) {
      const toHex = v => Math.max(0, Math.min(255, v)).toString(16).padStart(2, '0');
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }

    _buildBucketsForHex(hex, cycleMs, buckets) {
      const rgb = this._hexToRgbObj(hex);
      const invCycle = buckets / cycleMs;
      const hexs = new Array(buckets);
      const rgas = new Array(buckets);
      for (let i = 0; i < buckets; i++) {
        const phase = i / buckets;
        const t = phase <= 0.5 ? (phase / 0.5) : (1 - ((phase - 0.5) / 0.5));
        const blendRatio = 1 - t;
        const br = Math.round(rgb.r + (255 - rgb.r) * blendRatio);
        const bg = Math.round(rgb.g + (255 - rgb.g) * blendRatio);
        const bb = Math.round(rgb.b + (255 - rgb.b) * blendRatio);
        hexs[i] = this._rgbToHex(br, bg, bb);
        rgas[i] = `rgba(${br},${bg},${bb},${this.ghostAlpha})`;
      }
      return { buckets, cycleMs, invCycle, hexs, rgas, createdAt: Date.now(), lastUsed: Date.now() };
    }

    _cacheKey(hex, cycleMs, buckets) {
      return `${hex}|${cycleMs}|${buckets}`;
    }

    ensure(hex, cycleMs = this.cycleMs, buckets = this.buckets) {
      const k = this._cacheKey(hex, cycleMs, buckets);
      let entry = this._map.get(k);
      if (entry) { entry.lastUsed = Date.now(); return entry; }
      entry = this._buildBucketsForHex(hex, cycleMs, buckets);
      this._map.set(k, entry);
      if (this._map.size > this.dynamicLimit) {
        let oldestKey = null, oldestT = Infinity;
        for (const [key, val] of this._map) {
          const t = val.lastUsed || val.createdAt || 0;
          if (t < oldestT) { oldestT = t; oldestKey = key; }
        }
        if (oldestKey) this._map.delete(oldestKey);
      }
      return entry;
    }

    precompute(listOfHexes, cycleMs = this.cycleMs, buckets = this.buckets) {
      for (const hex of listOfHexes) this.ensure(hex, cycleMs, buckets);
    }

    getHex(hex, now = performance.now(), cycleMs = this.cycleMs, buckets = this.buckets) {
      const e = this.ensure(hex, cycleMs, buckets);
      const idx = Math.floor((now % e.cycleMs) * e.invCycle);
      return e.hexs[idx];
    }

    getGhost(hex, now = performance.now(), cycleMs = this.cycleMs, buckets = this.buckets) {
      const e = this.ensure(hex, cycleMs, buckets);
      const idx = Math.floor((now % e.cycleMs) * e.invCycle);
      return e.rgas[idx];
    }
  }

  const AnimCache = new AnimationColorCache({
    buckets: CONFIG.ANIM_BUCKETS,
    cycleMs: CONFIG.ANIM_CYCLE_MS,
    ghostAlpha: CONFIG.ANIM_GHOST_ALPHA,
    dynamicLimit: CONFIG.ANIM_DYNAMIC_CACHE_LIMIT
  });


  (function precomputeKnownAnimColors() {
    const tspinFlashColors = ['#FF8E0D', '#FF0D72', '#0DC2FF', '#FFE138', '#CCCCCC'];
    AnimCache.precompute(COLORS, CONFIG.ANIM_CYCLE_MS, CONFIG.ANIM_BUCKETS);
    AnimCache.precompute(tspinFlashColors, CONFIG.TSPIN_FLASH_CYCLE_MS, CONFIG.ANIM_BUCKETS);
  })();


  const pieceRotations = [
    [
      [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
      [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
      [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]
    ],
    [
      [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]
    ],
    [
      [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
      [[0,0,0,0],[1,1,1,0],[0,1,0,0],[0,0,0,0]],
      [[0,1,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]]
    ],
    [
      [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[1,0,0,0],[1,0,0,0],[1,1,0,0],[0,0,0,0]],
      [[0,0,0,0],[1,1,1,0],[1,0,0,0],[0,0,0,0]],
      [[1,1,0,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]]
    ],
    [
      [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,1,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],
      [[0,0,0,0],[1,1,1,0],[0,0,1,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,0,0],[1,1,0,0],[0,0,0,0]]
    ],
    [
      [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]],
      [[0,0,0,0],[0,1,1,0],[1,1,0,0],[0,0,0,0]],
      [[0,1,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]]
    ],
    [
      [[0,1,1,0],[0,0,1,1],[0,0,0,0],[0,0,0,0]],
      [[0,0,1,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
      [[0,0,0,0],[0,1,1,0],[0,0,1,1],[0,0,0,0]],
      [[0,0,1,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]]    
      ]
  ];

  (function attachPieceMetadata(){
  for (let p = 0; p < pieceRotations.length; p++) {
    const rotations = pieceRotations[p];
    for (let r = 0; r < rotations.length; r++) {
      const mat = rotations[r];
      if (!mat) continue;
      if (!mat._cells) {
        const cells = [];
        let minX = 4, minY = 4, maxX = 0, maxY = 0;
        for (let y = 0; y < 4; y++) {
          const row = mat[y] || [];
          for (let x = 0; x < 4; x++) {
            if (row[x]) {
              cells.push({ x, y });
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
            }
          }
        }
        mat._cells = cells;
        mat._bbox = { minX, minY, maxX, maxY, width: (maxX - minX + 1), height: (maxY - minY + 1) };
      }
    }
  }
})();


  const JLSTZ_KICKS = {
    '0->1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    '1->0': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
    '1->2': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
    '2->1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    '2->3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
    '3->2': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    '3->0': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    '0->3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]]
  };

  const I_KICKS = {
    '0->1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    '1->0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    '1->2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
    '2->1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    '2->3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    '3->2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    '3->0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    '0->3': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]]
  };

  const SZ_OPTIMIZED_KICKS = {
    '0->1': [[0,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2],[1,0],[-1,0],[0,-1]],
    '1->0': [[0,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2],[1,0],[-1,0],[0,-1]],
    '1->2': [[0,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2],[1,0],[-1,0],[0,-1]],
    '2->1': [[0,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2],[1,0],[-1,0],[0,-1]],
    '2->3': [[0,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2],[1,0],[-1,0],[0,-1]],
    '3->2': [[0,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2],[1,0],[-1,0],[0,-1]],
    '3->0': [[0,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2],[1,0],[-1,0],[0,-1]],
    '0->3': [[0,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2],[1,0],[-1,0],[0,-1]]
  };

  function generateFallbackPreferDown(maxX = 5, maxY = 5) {
    const arr = [];
    for (let dy = -maxY; dy <= maxY; dy++) for (let dx = -maxX; dx <= maxX; dx++) arr.push([dx, dy]);
    arr.sort((a, b) => {
      const ma = Math.abs(a[0]) + Math.abs(a[1]);
      const mb = Math.abs(b[0]) + Math.abs(b[1]);
      if (ma !== mb) return ma - mb;
      const aDown = a[1] > 0 ? -1 : (a[1] < 0 ? 1 : 0);
      const bDown = b[1] > 0 ? -1 : (b[1] < 0 ? 1 : 0);
      if (aDown !== bDown) return aDown - bDown;
      if (Math.abs(a[1]) !== Math.abs(b[1])) return Math.abs(a[1]) - Math.abs(b[1]);
      if (Math.abs(a[0]) !== Math.abs(b[0])) return Math.abs(a[0]) - Math.abs(b[0]);
      return a[0] - b[0];
    });
    const zi = arr.findIndex(p => p[0] === 0 && p[1] === 0);
    if (zi > 0) { arr.splice(zi, 1); arr.unshift([0, 0]); }
    return arr;
  }

  const FALLBACK_KICKS = generateFallbackPreferDown();
  const SZ_LIMITED_FALLBACK = generateFallbackPreferDown(3, 3);

  function sortKicksPreferDown(baseTests) {
    const testsWithIndex = baseTests.map((t, i) => ({ dx: t[0], dy: t[1], origIndex: i }));
    testsWithIndex.sort((a, b) => {
      const ma = Math.abs(a.dx) + Math.abs(a.dy);
      const mb = Math.abs(b.dx) + Math.abs(b.dy);
      if (ma !== mb) return ma - mb;
      const aDown = a.dy > 0 ? -1 : (a.dy < 0 ? 1 : 0);
      const bDown = b.dy > 0 ? -1 : (b.dy < 0 ? 1 : 0);
      if (aDown !== bDown) return aDown - bDown;
      if (Math.abs(a.dy) !== Math.abs(b.dy)) return Math.abs(a.dy) - Math.abs(b.dy);
      if (Math.abs(a.dx) !== Math.abs(b.dx)) return Math.abs(a.dx) - Math.abs(b.dx);
      return a.dx - b.dx;
    });
    return testsWithIndex;
  }

  const JL_EXTENDED_KICKS = {
    '0->1': [[-1,0],[-2,0],[1,0],[0,1],[0,2],[0,3],[-1,1],[1,1],[-1,2],[1,2]],
    '1->0': [[1,0],[2,0],[-1,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2]],
    '1->2': [[1,0],[2,0],[-1,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2]],
    '2->1': [[-1,0],[-2,0],[1,0],[0,1],[0,2],[0,3],[-1,1],[1,1],[-1,2],[1,2]],
    '2->3': [[1,0],[2,0],[-1,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2]],
    '3->2': [[-1,0],[-2,0],[1,0],[0,1],[0,2],[0,3],[-1,1],[1,1],[-1,2],[1,2]],
    '3->0': [[-1,0],[-2,0],[1,0],[0,1],[0,2],[0,3],[-1,1],[1,1],[-1,2],[1,2]],
    '0->3': [[1,0],[2,0],[-1,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2]]
  };

  const I_EXTENDED_KICKS = {
    '0->1': [[-2,0],[1,0],[-1,0],[0,1],[0,2],[0,3],[-1,1],[1,1],[-1,2],[1,2]],
    '1->0': [[2,0],[-1,0],[1,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2]],
    '1->2': [[2,0],[-1,0],[1,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2]],
    '2->1': [[-2,0],[1,0],[-1,0],[0,1],[0,2],[0,3],[-1,1],[1,1],[-1,2],[1,2]],
    '2->3': [[-1,0],[2,0],[1,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2]],
    '3->2': [[1,0],[-2,0],[-1,0],[0,1],[0,2],[0,3],[-1,1],[1,1],[-1,2],[1,2]],
    '3->0': [[1,0],[-2,0],[-1,0],[0,1],[0,2],[0,3],[1,1],[-1,1],[1,2],[-1,2]],
    '0->3': [[-1,0],[2,0],[1,0],[0,1],[0,2],[0,3],[-1,1],[1,1],[-1,2],[1,2]]
  };

  const SORTED_KICKS = { jl: {}, i: {}, sz: {} };
  (function precomputeSortedKicks(){
    for (const k in JLSTZ_KICKS) SORTED_KICKS.jl[k] = sortKicksPreferDown(JLSTZ_KICKS[k]);
    for (const k in I_KICKS) SORTED_KICKS.i[k] = sortKicksPreferDown(I_KICKS[k]);
    for (const k in SZ_OPTIMIZED_KICKS) SORTED_KICKS.sz[k] = sortKicksPreferDown(SZ_OPTIMIZED_KICKS[k]);
  })();


  class Randomizer {
    constructor(bagSize = 7) {
        this.bagSize = bagSize;
        this.queue = [];
    }

    _shuffleArray(a) {
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
    }

    _newShuffledBag() {
        const arr = [];
        for (let i = 0; i < this.bagSize; i++) arr.push(i);
        this._shuffleArray(arr);
        return arr;
    }

    ensure(minLen) {
        if (this.queue.length < minLen && this.queue.length <= this.bagSize) {
            const bag = this._newShuffledBag();
            this.queue.push(...bag);
        }
    }

    peek(n) {
        this.ensure(n);
        return this.queue.slice(0, n);
    }

    pop() {
        this.ensure(1);
        return this.queue.shift();
    }

    refill(previewCount) {
        this.queue = [];
        this.ensure(previewCount + 1);
    }
}


  class Board {
    constructor(cols, rows) {
      this.cols = Math.max(1, Math.floor(cols));
      this.rows = Math.max(1, Math.floor(rows));
      this.grid = new Uint8Array(this.cols * this.rows);
      this.rowBits = new Uint32Array(this.rows);
      if (this.cols >= 32) {
        let m = 0;
        for (let x = 0; x < this.cols; x++) m |= (1 << x);
        this.fullMask = m >>> 0;
      } else {
        this.fullMask = ((1 << this.cols) - 1) >>> 0;
      }
      this.colorToIndex = Object.create(null);
      for (let i = 0; i < COLORS.length; i++) this.colorToIndex[COLORS[i]] = i + 1;
      this.dirtyAll = true;
      this.dirtyRows = new Uint8Array(this.rows);
    }
    _idx(x, y) { return y * this.cols + x; }
    getIndexAt(x, y) { if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) return 0; return this.grid[this._idx(x, y)]; }
    getCell(x, y) { const idx = this.getIndexAt(x, y); return idx ? COLORS[idx - 1] : 0; }
    isOccupied(x, y) { if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) return true; return !!this.getIndexAt(x, y); }
    setCell(x, y, val) {
      if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) return;
      const i = this._idx(x, y);
      if (typeof val === 'number') this.grid[i] = val;
      else this.grid[i] = this.colorToIndex[val] || 1;
      if (this.grid[i]) this.rowBits[y] |= (1 << x);
      else this.rowBits[y] &= ~(1 << x);
      this.markRowDirty(y);
    }
    reset() { this.grid.fill(0); this.rowBits.fill(0); this.markAllDirty(); }
    markRowDirty(y) { if (y >= 0 && y < this.rows) this.dirtyRows[y] = 1; }
    markAllDirty() { this.dirtyAll = true; this.dirtyRows.fill(1); }
    collide(piece, pos) {
  if (!piece) return false;
  const px = Math.floor(pos.x);
  const pyBase = Math.floor(pos.y);
  for (let i = 0; i < piece._cells.length; i++) {
    const c = piece._cells[i];
    const bx = px + c.x;
    const by = pyBase + c.y;
    if (bx < 0 || bx >= this.cols || by >= this.rows) return true;
    if (by >= 0 && this.getIndexAt(bx, by)) return true;
  }
  return false;
}
    mergePiece(piece, pos, color) {
      if (piece && piece._cells && piece._cells.length) {
        for (let i = 0; i < piece._cells.length; i++) {
          const c = piece._cells[i];
          const bx = pos.x + c.x, by = pos.y + c.y;
          if (by >= 0 && by < this.rows && bx >= 0 && bx < this.cols) this.setCell(bx, by, color);
        }
        return;
      }
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          if (piece[y] && piece[y][x]) {
            const bx = pos.x + x, by = pos.y + y;
            if (by >= 0 && by < this.rows && bx >= 0 && bx < this.cols) this.setCell(bx, by, color);
          }
        }
      }
    }
    calculateFullLinesCount() {
      let count = 0;
      for (let y = 0; y < this.rows; y++) {
        if (this.rowBits[y] === this.fullMask) count++;
      }
      return count;
    }
    clearLinesReturnCount() {
      const newGrid = new Uint8Array(this.cols * this.rows);
      const newRowBits = new Uint32Array(this.rows);
      let writeRow = this.rows - 1;
      let lines = 0;
      for (let y = this.rows - 1; y >= 0; y--) {
        if (this.rowBits[y] === this.fullMask) { lines++; continue; }
        const src = y * this.cols, dst = writeRow * this.cols;
        newGrid.set(this.grid.subarray(src, src + this.cols), dst);
        newRowBits[writeRow] = this.rowBits[y];
        writeRow--;
      }
      this.grid = newGrid;
      this.rowBits = newRowBits;
      if (lines > 0) this.markAllDirty();
      return lines;
    }
    isBoardEmpty() {
      for (let y = 0; y < this.rows; y++) {
        if (this.rowBits[y] !== 0) return false;
      }
      return true;
    }
  }


  class Renderer {
    constructor(mainCtx, previewCtx, holdCtx, board, config) {
      this.ctx = mainCtx;
      this.previewCtx = previewCtx;
      this.holdCtx = holdCtx;
      this.board = board;
      this.config = config;
      this.blockSize = config.BLOCK_SIZE;
      this.previewBlockSize = 18;
      this.previewSlotPadding = 8;
      this.previewSlotHeight = this.previewBlockSize * 4 + this.previewSlotPadding;
      this.flash = { active: false, cells: new Set(), baseHex: null, startTime: 0, duration: CONFIG.TSPIN_FLASH_DURATION_MS, cycle: CONFIG.TSPIN_FLASH_CYCLE_MS, timeoutId: null };
      this._prevMovingRows = new Uint8Array(this.board.rows);
      this.pcMessage = { active: false, startTime: 0, duration: 5000 };
      this.setupPreviewCanvas();
      this.startMarkAllDirtyTimer();
    }
    setupPreviewCanvas() {
      previewCanvas.width = 100;
      previewCanvas.height = this.previewSlotHeight * CONFIG.PREVIEW_COUNT;
      previewCanvas.style.width = previewCanvas.width + 'px';
      previewCanvas.style.height = previewCanvas.height + 'px';
    }
    startMarkAllDirtyTimer() {
      setInterval(() => {
        this.board.markAllDirty();
      }, CONFIG.REFRESH_TIMER);
    }
    startFlashOverlay(cellsArray, baseHex, isPC = false) {
      if (!baseHex) return;
      if (this.flash.timeoutId) { clearTimeout(this.flash.timeoutId); this.flash.timeoutId = null; }
      this.flash.cells = new Set(cellsArray.map(c => `${c.x},${c.y}`));
      this.flash.baseHex = baseHex;
      this.flash.startTime = performance.now();
      this.flash.active = true;
      this.flash.cycle = isPC ? CONFIG.PC_FLASH_CYCLE_MS : CONFIG.TSPIN_FLASH_CYCLE_MS;
      this.flash.timeoutId = setTimeout(() => { this.stopFlashOverlay(); }, this.flash.duration + 20);
    }
    stopFlashOverlay() {
      if (this.flash.timeoutId) { clearTimeout(this.flash.timeoutId); this.flash.timeoutId = null; }
      this.flash.active = false;
      this.flash.cells = new Set();
      this.flash.baseHex = null;
    }
    getFlashColorAtCell(x, y, now) {
      if (!this.flash.active) return null;
      if (!this.flash.cells.has(`${x},${y}`)) return null;
      const elapsed = now - this.flash.startTime;
      if (elapsed < 0 || elapsed > this.flash.duration) return null;
      const entryHex = this.flash.baseHex;
      return AnimCache.getHex(entryHex, now, this.flash.cycle, CONFIG.ANIM_BUCKETS);
    }
    _rowsForPieceAt(piece, pos) {
      if (!piece) return null;
      if (piece._bbox) {
        const top = pos.y + piece._bbox.minY;
        const bottom = pos.y + piece._bbox.maxY;
        const t = Math.max(0, Math.floor(top));
        const b = Math.min(this.board.rows - 1, Math.floor(bottom));
        if (b < 0 || t > this.board.rows - 1) return null;
        return [t, b];
      }
      let t = Infinity, b = -Infinity;
      for (let y = 0; y < 4; y++) for (let x = 0; x < 4; x++) if (piece[y] && piece[y][x]) { t = Math.min(t, pos.y + y); b = Math.max(b, pos.y + y); }
      if (b === -Infinity) return null;
      const tt = Math.max(0, Math.floor(t));
      const bb = Math.min(this.board.rows - 1, Math.floor(b));
      if (bb < 0 || tt > this.board.rows - 1) return null;
      return [tt, bb];
    }
    draw(now, currentPiece, currentPos, currentColor, animColorHex, ghostColorStr) {
      if (this._prevMovingRows && this._prevMovingRows.length === this.board.rows) {
        for (let y = 0; y < this.board.rows; y++) if (this._prevMovingRows[y]) this.board.dirtyRows[y] = 1;
      }

      if (!this.board.dirtyAll) {
        for (let y = 0; y < this.board.rows; y++) {
          if (!this.board.dirtyRows[y]) continue;
          const py = y * this.blockSize;
          this.ctx.fillStyle = '#000';
          this.ctx.fillRect(0, py, this.board.cols * this.blockSize, this.blockSize);
          for (let x = 0; x < this.board.cols; x++) {
            const idx = this.board.getIndexAt(x, y);
            const flashColor = this.getFlashColorAtCell(x, y, now);
            if (flashColor) { this.ctx.fillStyle = flashColor; this.ctx.fillRect(x * this.blockSize, py, this.blockSize - 1, this.blockSize - 1); }
            else if (idx) { this.ctx.fillStyle = COLORS[idx - 1]; this.ctx.fillRect(x * this.blockSize, py, this.blockSize - 1, this.blockSize - 1); }
          }
          this.board.dirtyRows[y] = 0;
        }
      } else {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < this.board.rows; y++) {
          for (let x = 0; x < this.board.cols; x++) {
            const flashColor = this.getFlashColorAtCell(x, y, now);
            if (flashColor) { this.ctx.fillStyle = flashColor; this.ctx.fillRect(x * this.blockSize, y * this.blockSize, this.blockSize - 1, this.blockSize - 1); continue; }
            const idx = this.board.getIndexAt(x, y);
            if (idx) { this.ctx.fillStyle = COLORS[idx - 1]; this.ctx.fillRect(x * this.blockSize, y * this.blockSize, this.blockSize - 1, this.blockSize - 1); }
          }
        }
        this.board.dirtyAll = false;
        this.board.dirtyRows.fill(0);
      }

      if (currentPiece) {
        const ghostPos = this.getGhostPosition(currentPiece, currentPos);
        if (ghostPos.y > currentPos.y) {
          this.ctx.fillStyle = ghostColorStr || (currentColor + '33');
          if (currentPiece._cells && currentPiece._cells.length) {
            for (let i = 0; i < currentPiece._cells.length; i++) {
              const c = currentPiece._cells[i];
              this.ctx.fillRect((ghostPos.x + c.x) * this.blockSize, (ghostPos.y + c.y) * this.blockSize, this.blockSize - 1, this.blockSize - 1);
            }
          } else {
            for (let y = 0; y < 4; y++) for (let x = 0; x < 4; x++) if (currentPiece[y] && currentPiece[y][x]) this.ctx.fillRect((ghostPos.x + x) * this.blockSize, (ghostPos.y + y) * this.blockSize, this.blockSize - 1, this.blockSize - 1);
          }
        }
      }

      if (currentPiece) {
        if (!this.flash.active) {
          this.ctx.fillStyle = animColorHex || currentColor;
          if (currentPiece._cells && currentPiece._cells.length) {
            for (let i = 0; i < currentPiece._cells.length; i++) {
              const c = currentPiece._cells[i];
              this.ctx.fillRect((currentPos.x + c.x) * this.blockSize, (currentPos.y + c.y) * this.blockSize, this.blockSize - 1, this.blockSize - 1);
            }
          } else {
            for (let y = 0; y < 4; y++) for (let x = 0; x < 4; x++) if (currentPiece[y] && currentPiece[y][x]) this.ctx.fillRect((currentPos.x + x) * this.blockSize, (currentPos.y + y) * this.blockSize, this.blockSize - 1, this.blockSize - 1);
          }
        }
      }

      this._prevMovingRows.fill(0);
      if (currentPiece) {
        const curRange = this._rowsForPieceAt(currentPiece, currentPos);
        if (curRange) for (let y = curRange[0]; y <= curRange[1]; y++) this._prevMovingRows[y] = 1;
        const gPos = this.getGhostPosition(currentPiece, currentPos);
        const gRange = this._rowsForPieceAt(currentPiece, gPos);
        if (gRange) for (let y = gRange[0]; y <= gRange[1]; y++) this._prevMovingRows[y] = 1;
      }
      if (this.board.dirtyAll) this._prevMovingRows.fill(0);

      if (this.pcMessage.active) {
        const elapsed = now - this.pcMessage.startTime;
        if (elapsed > this.pcMessage.duration) {
          this.pcMessage.active = false;
          this.board.markAllDirty();
        } else {
          this.ctx.save();
          this.ctx.font = '40px Arial';
          this.ctx.fillStyle = '#FFFFFF';
          this.ctx.textAlign = 'center';
          this.ctx.textBaseline = 'middle';
          const centerX = (this.board.cols * this.blockSize) / 2;
          const centerY = (this.board.rows * this.blockSize) / 2;
          this.ctx.fillText('Perfect', centerX, centerY - 25);
          this.ctx.fillText('Clear!', centerX, centerY + 25);
          this.ctx.restore();
        }
      }
    }

    getGhostPosition(piece, pos) {
      const g = { x: Math.floor(pos.x), y: Math.floor(pos.y) };
      const maxIterations = Math.max(400, this.board.rows + 16);
      let iter = 0;
      while (!this.board.collide(piece, { x: g.x, y: g.y + 1 })) {
        g.y++;
        if (++iter > maxIterations) return g;
      }
      return g;
    }

    drawPreview(upcomingQueue) {
      const ctx = this.previewCtx;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      const upcoming = upcomingQueue.slice(0, CONFIG.PREVIEW_COUNT);
      const ox = Math.floor((previewCanvas.width - this.previewBlockSize * 4) / 2);
      for (let i = 0; i < CONFIG.PREVIEW_COUNT; i++) {
        const idx = upcoming[i];
        if (idx === undefined) continue;
        const piece = pieceRotations[idx][0];
        const color = COLORS[idx];
        const slotY = i * this.previewSlotHeight + Math.floor(this.previewSlotPadding / 2);
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(4, slotY, previewCanvas.width - 8, this.previewBlockSize * 4);
        ctx.fillStyle = color;
        for (let y = 0; y < 4; y++) for (let x = 0; x < 4; x++) if (piece[y] && piece[y][x]) ctx.fillRect(ox + x * this.previewBlockSize, slotY + y * this.previewBlockSize, this.previewBlockSize - 1, this.previewBlockSize - 1);
      }
    }

    drawHold(holdPiece, holdColor) {
      const ctxH = this.holdCtx;
      ctxH.fillStyle = '#000';
      ctxH.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
      if (holdPiece) this.drawPieceToCtx(ctxH, holdPiece, holdColor, holdCanvas);
    }

    drawPieceToCtx(context, piece, color, canvasEl) {
      const bs = 20;
      const ox = (canvasEl.width - piece[0].length * bs) / 2;
      const oy = (canvasEl.height - piece.length * bs) / 2;
      context.fillStyle = color;
      piece.forEach((row, y) => row.forEach((v, x) => { if (v) context.fillRect(ox + x * bs, oy + y * bs, bs - 1, bs - 1); }));
    }

    startPCMessage() {
      this.pcMessage.active = true;
      this.pcMessage.startTime = performance.now();
    }
  }


  class UIManager {
    constructor() {
      this.hiScore = 0; this.hiLevel = 1; this.hiCombo = 0; this.hiBtb = 0; this.hiPC = 0;
      this.loadHiRecords();
      if (hiResetBtn) hiResetBtn.addEventListener('click', () => {
        this.hiScore = 0; this.hiLevel = 1; this.hiCombo = 0; this.hiBtb = 0; this.hiPC = 0;
        this.saveHiRecords();
        this.updateHiUI();
      });
    }
    loadHiRecords() {
      try {
        const s = localStorage.getItem(STORAGE_KEY_SCORE);
        const l = localStorage.getItem(STORAGE_KEY_LEVEL);
        const c = localStorage.getItem(STORAGE_KEY_COMBO);
        const b = localStorage.getItem(STORAGE_KEY_BTB);
        const p = localStorage.getItem(STORAGE_KEY_PC);
        this.hiScore = s !== null ? parseInt(s, 10) || 0 : 0;
        this.hiLevel = l !== null ? parseInt(l, 10) || 1 : 1;
        this.hiCombo = c !== null ? parseInt(c, 10) || 0 : 0;
        this.hiBtb = b !== null ? parseInt(b, 10) || 0 : 0;
        this.hiPC = p !== null ? parseInt(p, 10) || 0 : 0;
      } catch (e) { this.hiScore = 0; this.hiLevel = 1; this.hiCombo = 0; this.hiBtb = 0; this.hiPC = 0; }
      this.updateHiUI();
    }
    saveHiRecords() {
      try {
        localStorage.setItem(STORAGE_KEY_SCORE, String(this.hiScore));
        localStorage.setItem(STORAGE_KEY_LEVEL, String(this.hiLevel));
        localStorage.setItem(STORAGE_KEY_COMBO, String(this.hiCombo));
        localStorage.setItem(STORAGE_KEY_BTB, String(this.hiBtb));
        localStorage.setItem(STORAGE_KEY_PC, String(this.hiPC));
      } catch (e) {}
    }
    updateHiUI() {
      if (hiScoreEl) hiScoreEl.textContent = String(this.hiScore);
      if (hiLevelEl) hiLevelEl.textContent = String(this.hiLevel);
      if (hiComboEl) hiComboEl.textContent = String(this.hiCombo);
      if (hiBtbEl) hiBtbEl.textContent = String(this.hiBtb);
      if (hiPcEl) hiPcEl.textContent = String(this.hiPC);
    }
    updateComboBtbUI(combo, btb) {
      if (comboValueEl) comboValueEl.textContent = String(combo);
      if (btbValueEl) btbValueEl.textContent = String(btb);
    }
    considerUpdateHiRecords(score, level, combo, btb, pc) {
      let changed = false;
      if (score > this.hiScore) { this.hiScore = score; changed = true; }
      if (level > this.hiLevel) { this.hiLevel = level; changed = true; }
      if (combo > this.hiCombo) { this.hiCombo = combo; changed = true; }
      if (btb > this.hiBtb) { this.hiBtb = btb; changed = true; }
      if (pc > this.hiPC) { this.hiPC = pc; changed = true; }
      if (changed) { this.updateHiUI(); this.saveHiRecords(); }
    }
  }


  class InputManager {
    constructor() {
      this._resizeTimer = null;
      window.addEventListener('resize', () => { clearTimeout(this._resizeTimer); this._resizeTimer = setTimeout(() => this.rebuildButtonLabels(), 150); });
    }
    makeRepeatButton(btn, action) {
      if (!btn) return;
      let t = null;
      const initial = CONFIG.INITIAL_DELAY, interval = CONFIG.INTERVAL_DELAY;
      function start() { action(); t = setTimeout(function again() { action(); t = setTimeout(again, interval); }, initial); }
      function stop() { if (t) { clearTimeout(t); t = null; } }
      btn.addEventListener('mousedown', e => { e.preventDefault(); start(); });
      btn.addEventListener('mouseup', stop);
      btn.addEventListener('mouseleave', stop);
      btn.addEventListener('touchstart', e => { e.preventDefault(); start(); }, { passive: false });
      btn.addEventListener('touchend', stop);
      btn.addEventListener('contextmenu', e => { e.preventDefault(); });
    }
    instantButton(btn, action) {
      if (!btn) return;
      btn.addEventListener('click', e => { e.preventDefault(); action(); });
      btn.addEventListener('touchend', e => { e.preventDefault(); action(); }, { passive: false });
      btn.addEventListener('contextmenu', e => { e.preventDefault(); });
    }
    makeShortPressButton(btn, action, maxMs = 200) {
      if (!btn) return;
      let startTime = null;
      let isDown = false;
      const start = (e) => {
        e.preventDefault();
        startTime = Date.now();
        isDown = true;
      };
      const stop = (e) => {
        if (!isDown) return;
        e.preventDefault();
        isDown = false;
        const duration = Date.now() - startTime;
        if (duration <= maxMs) {
          action();
        }
        startTime = null;
      };
      const cancel = () => {
        isDown = false;
        startTime = null;
      };
      btn.addEventListener('mousedown', start);
      btn.addEventListener('mouseup', stop);
      btn.addEventListener('mouseleave', cancel);
      btn.addEventListener('touchstart', start, { passive: false });
      btn.addEventListener('touchend', stop, { passive: false });
      btn.addEventListener('touchcancel', cancel);
      btn.addEventListener('contextmenu', e => { e.preventDefault(); });
    }
    setupCanvasLabel(btn, text) {
      const label = (text || btn.getAttribute('aria-label') || btn.textContent || '').trim();
      if (!label) return;
      btn.setAttribute('aria-label', label);
      btn.textContent = '';
      if (btn._labelCanvas && btn._labelCanvas.parentNode === btn) { btn.removeChild(btn._labelCanvas); btn._labelCanvas = null; }
      const cs = getComputedStyle(btn);
      const padL = parseFloat(cs.paddingLeft) || 0;
      const padR = parseFloat(cs.paddingRight) || 0;
      const padT = parseFloat(cs.paddingTop) || 0;
      const padB = parseFloat(cs.paddingBottom) || 0;
      const clientW = Math.max(0, btn.clientWidth);
      const clientH = Math.max(0, btn.clientHeight);
      let contentW = Math.max(2, clientW - padL - padR);
      let contentH = Math.max(2, clientH - padT - padB);
      const tmpCtx = document.createElement('canvas').getContext('2d');
      const defaultFontSize = parseFloat(cs.fontSize) || 14;
      const fontWeight = cs.fontWeight || '600';
      const fontFamily = cs.fontFamily || 'Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
      tmpCtx.font = `${fontWeight} ${defaultFontSize}px ${fontFamily}`;
      const measuredW = Math.ceil(tmpCtx.measureText(label).width);
      const measuredH = Math.ceil(defaultFontSize * 1.3);
      if (contentW < 8) contentW = measuredW + 8;
      if (contentH < 8) contentH = measuredH + 4;
      const dpr = window.devicePixelRatio || 1;
      const c = document.createElement('canvas');
      c.className = 'btn-label-canvas';
      c.setAttribute('aria-hidden', 'true');
      const cssW = Math.max(1, Math.floor(contentW));
      const cssH = Math.max(1, Math.floor(contentH));
      c.style.width = cssW + 'px';
      c.style.height = cssH + 'px';
      c.width = Math.max(1, Math.ceil(cssW * dpr));
      c.height = Math.max(1, Math.ceil(cssH * dpr));
      c.style.display = 'inline-block';
      c.style.verticalAlign = 'middle';
      c.style.lineHeight = 'normal';
      c.style.margin = '0';
      c.style.padding = '0';
      c.style.border = '0';
      c.style.background = 'transparent';
      const g = c.getContext('2d');
      g.scale(dpr, dpr);
      let fs = defaultFontSize;
      fs = Math.min(fs, Math.floor(cssH * 0.9));
      g.font = `${fontWeight} ${fs}px ${fontFamily}`;
      let tw = g.measureText(label).width;
      while (tw > cssW - 4 && fs > 6) { fs -= 1; g.font = `${fontWeight} ${fs}px ${fontFamily}`; tw = g.measureText(label).width; }
      const estimatedTextHeight = fs;
      if (estimatedTextHeight > cssH * 0.95) {
        fs = Math.floor(cssH * 0.9);
        g.font = `${fontWeight} ${fs}px ${fontFamily}`;
        tw = g.measureText(label).width;
        while (tw > cssW - 4 && fs > 6) { fs -= 1; g.font = `${fontWeight} ${fs}px ${fontFamily}`; tw = g.measureText(label).width; }
      }
      g.clearRect(0, 0, cssW, cssH);
      g.fillStyle = cs.color || '#E1E1E1';
      g.textBaseline = 'middle';
      g.textAlign = 'center';
      const cx = cssW / 2, cy = cssH / 2;
      g.fillText(label, cx, cy);
      btn.appendChild(c);
      btn._labelCanvas = c;
      btn.addEventListener('contextmenu', e => e.preventDefault());
      btn.addEventListener('selectstart', e => e.preventDefault());
      btn._repaintCanvasLabel = () => { setTimeout(() => this.setupCanvasLabel(btn, label), 0); };
    }
    initAllButtonCanvasLabels() {
      const targets = [
        document.getElementById('btn-hold'),
        document.getElementById('btn-left'),
        document.getElementById('btn-right'),
        document.getElementById('btn-rot-ccw'),
        document.getElementById('btn-rot-cw'),
        document.getElementById('btn-soft'),
        document.getElementById('btn-hard'),
        document.getElementById('hi-reset')
      ].filter(Boolean);
      const labels = ['Hold', '← Left', 'Right →', 'Rotate ↺ (CCW)', 'Rotate ↻ (CW)', 'Soft Drop', 'Hard Drop', 'Reset'];
      targets.forEach((btn, i) => this.setupCanvasLabel(btn, labels[i]));
    }
    rebuildButtonLabels() { document.querySelectorAll('.btn-label-canvas').forEach(c => { if (c && c.parentNode) c.parentNode.removeChild(c); }); this.initAllButtonCanvasLabels(); }
  }

  const frontCorners = [
    [[-1, -1], [1, -1]],      [[1, -1], [1, 1]],        [[-1, 1], [1, 1]],        [[-1, -1], [-1, 1]]  ];

  class SoundManager {
  constructor() {
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }

  playComboSound(combo) {
    if (combo < 1) return;
    const baseFreq = 540;
    const freq = baseFreq * Math.pow(2, (combo - 1) * (2 / 12)); 
    const duration = CONFIG.SFX_DURATION; 

    const oscillator = this.audioContext.createOscillator();
    oscillator.type = 'sine';       
    oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);

    const gainNode = this.audioContext.createGain();
    gainNode.gain.setValueAtTime(CONFIG.SFX_VOLUME, this.audioContext.currentTime); 
    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration); 

    oscillator.connect(gainNode);
    gainNode.connect(this.audioContext.destination);

    oscillator.start();
    oscillator.stop(this.audioContext.currentTime + duration);
  }

  playB2BSound(shiftSemitones) {
    const baseDo = 523.25; 
    const baseRe = baseDo * Math.pow(2, 2 / 12); 
    const baseMi = baseDo * Math.pow(2, 4 / 12); 

    const shiftFactor = Math.pow(2, shiftSemitones / 12);
    const freqDo = baseDo * shiftFactor;
    const freqRe = baseRe * shiftFactor;
    const freqMi = baseMi * shiftFactor;

    const durationPerNote = 0.15; 
    const startTime = this.audioContext.currentTime;

    this._playNote(freqDo, startTime, durationPerNote);

    this._playNote(freqRe, startTime + durationPerNote, durationPerNote);

    this._playNote(freqMi, startTime + 2 * durationPerNote, durationPerNote);
  }

  _playNote(freq, startTime, duration) {
    const oscillator = this.audioContext.createOscillator();
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(freq, startTime);

    const gainNode = this.audioContext.createGain();
    gainNode.gain.setValueAtTime(CONFIG.SFX_VOLUME, startTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

    oscillator.connect(gainNode);
    gainNode.connect(this.audioContext.destination);

    oscillator.start(startTime);
    oscillator.stop(startTime + duration);
  }
}

  class Game {
  constructor() {
    this.blockSize = CONFIG.BLOCK_SIZE;
    this.cols = canvas.width / this.blockSize;
    this.rows = canvas.height / this.blockSize;
    this.board = new Board(this.cols, this.rows);
    this.randomizer = new Randomizer();
    this.renderer = new Renderer(ctx, previewCtx, holdCtx, this.board, CONFIG);
    this.ui = new UIManager();
    this.input = new InputManager();
    this.soundManager = new SoundManager();
    this.score = 0;
    this.level = 1;
    this.linesClearedTotal = 0;
    this.comboCount = 0;
    this.btbCount = 0;
    this.backToBack = false;
    this.pcCount = 0;
    this.canHold = true;
    this.currentPiece = null;
    this.currentPieceIndex = 0;
    this.currentPiecePos = { x: 0, y: 0 };
    this.currentColor = '';
    this.rotationState = 0;
    this.holdPiece = null;
    this.holdPieceIndex = -1;
    this.holdColor = '';
    this.groundedSince = null;
    this.lastKick = null;
    this.rotationIdCounter = 0;
    this.pieceSpawnTime = 0;
    this.pieceSpawnRotationId = 0;
    this.lastFlashTspinType = 'none';
    this.lastFlashPredictedCleared = 0;
    this.lastFlashCells = new Set();
    this.dropCounter = 0;
    this.lastTime = 0;
    this.PREVIEW_COUNT = CONFIG.PREVIEW_COUNT;
    this.randomizer.refill(this.PREVIEW_COUNT);
    this.setupButtons();
    this.input.initAllButtonCanvasLabels();
    this.ui.updateComboBtbUI(this.comboCount, this.btbCount);
    this.lastAction = null;
    this.createPiece(true);
    this._boundUpdate = this.update.bind(this);
    this._rafId = requestAnimationFrame(this._boundUpdate);
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        cancelAnimationFrame(this._rafId);
      } else {
        this.board.markAllDirty();
        this.lastTime = performance.now();
        this._rafId = requestAnimationFrame(this._boundUpdate);
        this.input.rebuildButtonLabels();  
      }
    });

    window.addEventListener('focus', () => {
      this.board.markAllDirty();
      this.lastTime = performance.now();
      this._rafId = requestAnimationFrame(this._boundUpdate);
      this.input.rebuildButtonLabels();  
    });
  }

  clonePiece(p) { return p.map(r => r.slice()); }

  countOccupiedCorners(pos, rotationState) {
    const cx = Math.floor(pos.x) + 1;
    const cy = Math.floor(pos.y) + 1;
    const isOccupied = (x, y) => this.board.isOccupied(x, y);
    const cornerOcc = [
      isOccupied(cx - 1, cy - 1),
      isOccupied(cx + 1, cy - 1),
      isOccupied(cx - 1, cy + 1),
      isOccupied(cx + 1, cy + 1)
    ];
    return cornerOcc.filter(Boolean).length;
  }

  isFrontBlocked(pos, rotationState) {
    const cx = Math.floor(pos.x) + 1;
    const cy = Math.floor(pos.y) + 1;
    const isOccupied = (x, y) => this.board.isOccupied(x, y);
    const fc = frontCorners[rotationState % 4];
    return isOccupied(cx + fc[0][0], cy + fc[0][1]) && isOccupied(cx + fc[1][0], cy + fc[1][1]);
  }

  detectTSpin(lastKick, pos, rotationState, pieceIndex, clearedLines = null) {
    if (pieceIndex !== 2 || this.lastAction !== 'rotate') return 'none';
    if (!lastKick) return 'none';
    if (typeof lastKick.rotationId === 'number' && lastKick.rotationId <= this.pieceSpawnRotationId) return 'none';
    if (lastKick.time < this.pieceSpawnTime) return 'none';
    const cat = lastKick.category || 'none';
    if (cat === 'triple') return 'full';
    const occ = this.countOccupiedCorners(pos, rotationState);
    if (occ < 3) return 'none';
    if (cat === 'mini') {
      if (occ === 3 && !this.isFrontBlocked(pos, rotationState)) {
        if ((clearedLines !== null && clearedLines >= 2) || Math.abs(lastKick.dy) > 1) return 'full';
        return 'mini';
      } else return 'full';
    }
    if (cat === 'fallback') {
      if (Math.abs(lastKick.dy) > 1) return 'full';
    }
    return 'full';
  }

  detectTPreferSide() {
    if (this.currentPiecePos.x <= 1) return +1;
    if (this.currentPiecePos.x >= this.cols - 5) return -1;
    const xL0 = Math.max(0, this.currentPiecePos.x - 2);
    const xL1 = Math.max(0, this.currentPiecePos.x - 1);
    const xR0 = Math.min(this.cols - 1, this.currentPiecePos.x + 3);
    const xR1 = Math.min(this.cols - 1, this.currentPiecePos.x + 4);
    const y0 = Math.max(0, this.currentPiecePos.y - 1);
    const y1 = Math.min(this.rows - 1, this.currentPiecePos.y + 2);
    let leftOcc = 0, rightOcc = 0;
    for (let y = y0; y <= y1; y++) {
      if (this.board.getIndexAt(xL0, y)) leftOcc++; if (this.board.getIndexAt(xL1, y)) leftOcc++;
      if (this.board.getIndexAt(xR0, y)) rightOcc++; if (this.board.getIndexAt(xR1, y)) rightOcc++;
    }
    if (leftOcc > rightOcc + 1) return +1;
    if (rightOcc > leftOcc + 1) return -1;
    return 0;
  }

  expandSym(mag, dy, prefer) {
    if (mag === 0) return [[0, dy]];
    if (prefer > 0) return [[+mag, dy], [-mag, dy]];
    if (prefer < 0) return [[-mag, dy], [+mag, dy]];
    return [[+mag, dy], [-mag, dy]];
  }

  tMiniCandidates(prefer) {
    const out = [];
    out.push(...this.expandSym(0, 2, prefer));
    out.push(...this.expandSym(1, 2, prefer));
    out.push(...this.expandSym(0, 1, prefer));
    out.push(...this.expandSym(1, 1, prefer));
    out.push(...this.expandSym(1, 0, prefer));
    out.push(...this.expandSym(2, 0, prefer));
    out.push(...this.expandSym(0, 0, prefer));
    out.push(...this.expandSym(0, -1, prefer));
    out.push(...this.expandSym(1, -1, prefer));
    out.push(...this.expandSym(0, -2, prefer));
    out.push(...this.expandSym(1, -2, prefer));
    return out;
  }

  tTripleCandidates(prefer) {
    const out = [];
    out.push(...this.expandSym(0, 5, prefer));
    out.push(...this.expandSym(1, 5, prefer));
    out.push(...this.expandSym(2, 5, prefer));
    out.push(...this.expandSym(3, 5, prefer));
    out.push(...this.expandSym(0, 4, prefer));
    out.push(...this.expandSym(1, 4, prefer));
    out.push(...this.expandSym(2, 4, prefer));
    out.push(...this.expandSym(3, 4, prefer));
    out.push(...this.expandSym(0, 3, prefer));
    out.push(...this.expandSym(1, 3, prefer));
    out.push(...this.expandSym(2, 3, prefer));
    out.push(...this.expandSym(0, 2, prefer));
    out.push(...this.expandSym(1, 2, prefer));
    out.push(...this.expandSym(2, 2, prefer));
    out.push(...this.expandSym(3, 2, prefer));
    out.push(...this.expandSym(1, 1, prefer));
    out.push(...this.expandSym(2, 1, prefer));
    out.push(...this.expandSym(0, 0, prefer));
    out.push(...this.expandSym(1, 0, prefer));
    out.push(...this.expandSym(2, 0, prefer));
    out.push(...this.expandSym(0, -1, prefer));
    out.push(...this.expandSym(1, -1, prefer));
    out.push(...this.expandSym(2, -1, prefer));
    out.push(...this.expandSym(0, -2, prefer));
    out.push(...this.expandSym(1, -2, prefer));
    return out;
  }

  tryRotateWithKicks(dir = 1) {
    if (!this.currentPiece) return { success: false, usedKickIndex: -1, fallbackUsed: false };
    if (this.currentPieceIndex === 1) {
      this.rotationState = (this.rotationState + (dir === 1 ? 1 : 3)) % 4;
      this.currentPiece = pieceRotations[1][this.rotationState];
      this.rotationIdCounter++;
      this.lastKick = { dx: 0, dy: 0, category: 'none', source: 'o-block', index: 0, time: performance.now(), rotationId: this.rotationIdCounter };
      if (!this.isGrounded()) this.groundedSince = null;
      return { success: true, usedKickIndex: 0, fallbackUsed: false };
    }

    const from = this.rotationState;
    const to = (this.rotationState + (dir === 1 ? 1 : 3)) % 4;
    const rotated = pieceRotations[this.currentPieceIndex][to];
    const key = `${from}->${to}`;
    if (!this.board.collide(rotated, this.currentPiecePos)) {
      this.currentPiece = rotated;
      this.rotationState = to;
      this.rotationIdCounter++;
      this.lastKick = { dx: 0, dy: 0, category: 'none', source: 'none', index: 0, time: performance.now(), rotationId: this.rotationIdCounter };
      if (this.currentPieceIndex === 2) this.lastKick.predicted = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex);
      if (!this.isGrounded()) this.groundedSince = null;
      if (this.currentPieceIndex === 2) { this.lastAction = 'rotate'; }
      return { success: true, usedKickIndex: 0, fallbackUsed: false };
    }
    if (this.currentPieceIndex === 2) {
      const prefer = this.detectTPreferSide();
      const miniList = this.tMiniCandidates(prefer);
      for (let i = 0; i < miniList.length; i++) {
        const [dx, dy] = miniList[i];
        const testPos = { x: this.currentPiecePos.x + dx, y: this.currentPiecePos.y + dy };
        if (testPos.x < -6 || testPos.x > this.cols + 6) continue;
        if (testPos.y < -8 || testPos.y > this.rows + 6) continue;
        if (!this.board.collide(rotated, testPos)) {
          this.currentPiece = rotated;
          this.currentPiecePos = testPos;
          this.rotationState = to;
          this.rotationIdCounter++;
          this.lastKick = { dx, dy, category: 'mini', source: 't-mini', index: i + 1, time: performance.now(), rotationId: this.rotationIdCounter };
          if (this.currentPieceIndex === 2 && this.lastKick.category !== 'none') this.lastKick.predicted = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex);
          if (!this.isGrounded()) this.groundedSince = null;
          if (this.currentPieceIndex === 2) { this.lastAction = 'rotate'; }
          return { success: true, usedKickIndex: i + 1, fallbackUsed: false };
        }
      }

      const tripleList = this.tTripleCandidates(this.detectTPreferSide());
      for (let i = 0; i < tripleList.length; i++) {
        const [dx, dy] = tripleList[i];
        const testPos = { x: this.currentPiecePos.x + dx, y: this.currentPiecePos.y + dy };
        if (testPos.x < -6 || testPos.x > this.cols + 6) continue;
        if (testPos.y < -10 || testPos.y > this.rows + 6) continue;
        if (!this.board.collide(rotated, testPos)) {
          this.currentPiece = rotated;
          this.currentPiecePos = testPos;
          this.rotationState = to;
          this.rotationIdCounter++;
          this.lastKick = { dx, dy, category: 'triple', source: 't-triple', index: i + 1, time: performance.now(), rotationId: this.rotationIdCounter };
          if (this.currentPieceIndex === 2 && this.lastKick.category !== 'none') this.lastKick.predicted = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex);
          if (!this.isGrounded()) this.groundedSince = null;
          if (this.currentPieceIndex === 2) { this.lastAction = 'rotate'; }
          return { success: true, usedKickIndex: i + 1, fallbackUsed: false };
        }
      }
    }

    if (this.currentPieceIndex === 5 || this.currentPieceIndex === 6) {
      const szTests = SZ_OPTIMIZED_KICKS[key] || [];
      for (let i = 0; i < szTests.length; i++) {
        const [dx, dy] = szTests[i];
        const testPos = { x: this.currentPiecePos.x + dx, y: this.currentPiecePos.y + dy };
        if (testPos.x < -6 || testPos.x > this.cols + 6) continue;
        if (testPos.y < -10 || testPos.y > this.rows + 6) continue;
        if (!this.board.collide(rotated, testPos)) {
          this.currentPiece = rotated;
          this.currentPiecePos = testPos;
          this.rotationState = to;
          this.rotationIdCounter++;
          this.lastKick = { dx, dy, category: 'sz-optimized', source: 'sz-opt', index: i + 1, time: performance.now(), rotationId: this.rotationIdCounter };
          if (this.currentPieceIndex === 2 && this.lastKick.category !== 'none') this.lastKick.predicted = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex);
          if (!this.isGrounded()) this.groundedSince = null;
          if (this.currentPieceIndex === 2) { this.lastAction = 'rotate'; }
          return { success: true, usedKickIndex: i + 1, fallbackUsed: false };
        }
      }
    }

    const useExtended = (this.currentPieceIndex === 0) || (this.currentPieceIndex === 3) || (this.currentPieceIndex === 4);
    if (useExtended) {
      let extMap = null;
      let extSource = 'extended';
      if (this.currentPieceIndex === 0) { extMap = I_EXTENDED_KICKS; extSource = 'extended-i'; }
      else { extMap = JL_EXTENDED_KICKS; extSource = 'extended-jl'; }
      const extTests = (extMap && extMap[key]) ? extMap[key] : null;
      if (extTests && extTests.length) {
        for (let i = 0; i < extTests.length; i++) {
          const [dx, dy] = extTests[i];
          const testPos = { x: this.currentPiecePos.x + dx, y: this.currentPiecePos.y + dy };
          if (testPos.x < -6 || testPos.x > this.cols + 6) continue;
          if (testPos.y < -10 || testPos.y > this.rows + 6) continue;
          if (!this.board.collide(rotated, testPos)) {
            this.currentPiece = rotated;
            this.currentPiecePos = testPos;
            this.rotationState = to;
            this.rotationIdCounter++;
            this.lastKick = { dx, dy, category: 'extended', source: extSource, index: i + 1, time: performance.now(), rotationId: this.rotationIdCounter };
            if (this.currentPieceIndex === 2 && this.lastKick.category !== 'none') this.lastKick.predicted = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex);
            if (!this.isGrounded()) this.groundedSince = null;
            if (this.currentPieceIndex === 2) { this.lastAction = 'rotate'; }
            return { success: true, usedKickIndex: (i + 1), fallbackUsed: false };
          }
        }
      }
    }

    const baseKicks = (this.currentPieceIndex === 0) ? I_KICKS : JLSTZ_KICKS;
    const baseTests = baseKicks[key] || [[0, 0]];
    let orderedBase = null;
    if (this.currentPieceIndex === 0) orderedBase = SORTED_KICKS.i[key] || sortKicksPreferDown(baseTests);
    else orderedBase = SORTED_KICKS.jl[key] || sortKicksPreferDown(baseTests);
    for (let i = 0; i < orderedBase.length; i++) {
      const dx = orderedBase[i].dx, dy = orderedBase[i].dy;
      const testPos = { x: this.currentPiecePos.x + dx, y: this.currentPiecePos.y + dy };
      if (testPos.x < -6 || testPos.x > this.cols + 6) continue;
      if (testPos.y < -8 || testPos.y > this.rows + 6) continue;
      if (!this.board.collide(rotated, testPos)) {
        this.currentPiece = rotated;
        this.currentPiecePos = testPos;
        this.rotationState = to;
        this.rotationIdCounter++;
        const originalIndex = orderedBase[i].origIndex;
        const usedIndex = (dx !== 0 || dy !== 0) ? (originalIndex + 1) : 0;
        this.lastKick = { dx, dy, category: (usedIndex === 0 ? 'none' : 'base'), source: 'srs-base', index: usedIndex, time: performance.now(), rotationId: this.rotationIdCounter };
        if (this.currentPieceIndex === 2 && this.lastKick.category !== 'none') this.lastKick.predicted = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex);
        if (!this.isGrounded()) this.groundedSince = null;
        if (this.currentPieceIndex === 2) { this.lastAction = 'rotate'; }
        return { success: true, usedKickIndex: usedIndex, fallbackUsed: false };
      }
    }

    if (this.currentPieceIndex === 5 || this.currentPieceIndex === 6) {
      for (let i = 0; i < SZ_LIMITED_FALLBACK.length; i++) {
        const [dx, dy] = SZ_LIMITED_FALLBACK[i];
        const testPos = { x: this.currentPiecePos.x + dx, y: this.currentPiecePos.y + dy };
        if (testPos.x < -6 || testPos.x > this.cols + 6) continue;
        if (testPos.y < -10 || testPos.y > this.rows + 6) continue;
        if (!this.board.collide(rotated, testPos)) {
          this.currentPiece = rotated;
          this.currentPiecePos = testPos;
          this.rotationState = to;
          this.rotationIdCounter++;
          const usedIndex = ((dx !== 0 || dy !== 0) ? (i + 1) : 0) + 200;
          this.lastKick = { dx, dy, category: 'fallback-sz', source: 'sz-limited-fallback', index: usedIndex, time: performance.now(), rotationId: this.rotationIdCounter };
          if (this.currentPieceIndex === 2 && this.lastKick.category !== 'none') this.lastKick.predicted = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex);
          if (!this.isGrounded()) this.groundedSince = null;
          if (this.currentPieceIndex === 2) { this.lastAction = 'rotate'; }
          return { success: true, usedKickIndex: usedIndex, fallbackUsed: true };
        }
      }
    }

    for (let i = 0; i < FALLBACK_KICKS.length; i++) {
      const [dx, dy] = FALLBACK_KICKS[i];
      const testPos = { x: this.currentPiecePos.x + dx, y: this.currentPiecePos.y + dy };
      if (testPos.x < -6 || testPos.x > this.cols + 6) continue;
      if (testPos.y < -10 || testPos.y > this.rows + 6) continue;
      if (!this.board.collide(rotated, testPos)) {
        this.currentPiece = rotated;
        this.currentPiecePos = testPos;
        this.rotationState = to;
        this.rotationIdCounter++;
        const usedIndex = ((dx !== 0 || dy !== 0) ? (i + 1) : 0) + 100;
        this.lastKick = { dx, dy, category: 'fallback', source: 'fallback', index: usedIndex, time: performance.now(), rotationId: this.rotationIdCounter };
        if (this.currentPieceIndex === 2 && this.lastKick.category !== 'none') this.lastKick.predicted = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex);
        if (!this.isGrounded()) this.groundedSince = null;
        if (this.currentPieceIndex === 2) { this.lastAction = 'rotate'; }
        return { success: true, usedKickIndex: usedIndex, fallbackUsed: true };
      }
    }
    return { success: false, usedKickIndex: -1, fallbackUsed: false };
  }

  isGrounded() { return this.board.collide(this.currentPiece, { x: this.currentPiecePos.x, y: this.currentPiecePos.y + 1 }); }

  getGhostPosition() {
    const g = { x: Math.floor(this.currentPiecePos.x), y: Math.floor(this.currentPiecePos.y) };
    const maxIterations = Math.max(400, this.rows + 16);
    let iter = 0;
    while (!this.board.collide(this.currentPiece, { x: g.x, y: g.y + 1 })) {
      g.y++;
      if (++iter > maxIterations) return g;
    }
    return g;
  }

  applyScoring(lines, tspinType, isPerfectClear) {
    this.linesClearedTotal += lines;
    let baseScore = 0;
    if (lines === 1) baseScore = 1 * this.level;
    else if (lines === 2) baseScore = 2 * this.level;
    else if (lines === 3) baseScore = 3 * this.level;
    else if (lines === 4) baseScore = 4 * this.level;

    if (tspinType !== 'none') {
      if (tspinType === 'mini') {
        if (lines === 0) baseScore = 1 * this.level;
        else if (lines === 1) baseScore = 2 * this.level;
        else if (lines === 2) baseScore = 4 * this.level;
        else if (lines === 3) baseScore = 6 * this.level;
      } else {
        if (lines === 0) baseScore = 2 * this.level;
        else if (lines === 1) baseScore = 3 * this.level;
        else if (lines === 2) baseScore = 6 * this.level;
        else if (lines === 3) baseScore = 9 * this.level;
      }
    }

    if (isPerfectClear) {
      let pcBonus = 0;
      if (lines === 1) pcBonus = 10 * this.level;
      else if (lines === 2) pcBonus = 15 * this.level;
      else if (lines === 3) pcBonus = 20 * this.level;
      else if (lines === 4) pcBonus = 25 * this.level;
      baseScore = Math.max(baseScore, pcBonus); 
      this.pcCount++;
    }

    const isDifficult = (lines === 4) || (tspinType !== 'none' && lines > 0) || isPerfectClear; 
    let comboBonus = 0;
    if (lines > 0) {
      this.comboCount += 1;
    } else {
      this.comboCount = 0;
    }
    if (this.comboCount > 1) comboBonus = (this.comboCount - 1) * 5 * this.level;
    let btbMultiplier = 1;
    if (isDifficult) {
      if (this.backToBack) {
        btbMultiplier = 1.5;
        this.btbCount += 1;
      } else {
        this.backToBack = true;
        this.btbCount = 0;
      }
    } else if (lines > 0) {
      this.backToBack = false;
      this.btbCount = 0;
    }
    const added = Math.round(baseScore * btbMultiplier) + comboBonus;
    this.score += added;
    const newLevel = Math.floor(this.linesClearedTotal / CONFIG.LEVEL_UP_FACTOR) + 1;
    if (newLevel !== this.level) this.level = newLevel;
    if (scoreEl) scoreEl.textContent = `Score: ${this.score}`;
    if (levelEl) levelEl.textContent = `Level: ${this.level}`;
    this.ui.updateComboBtbUI(this.comboCount, this.btbCount);
    this.ui.considerUpdateHiRecords(this.score, this.level, this.comboCount, this.btbCount, this.pcCount);

    if (lines > 0) {
      if (isDifficult) {
        this.soundManager.playB2BSound(Math.min(this.btbCount, 10));
      } else {
        this.soundManager.playComboSound(this.comboCount);
      }
    }
  }

  lockNow() {
    this.board.mergePiece(this.currentPiece, this.currentPiecePos, this.currentColor);
    const cleared = this.board.calculateFullLinesCount();
    let tspinType = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex, cleared);
    this.lastMoveWasTSpin = tspinType;
    const linesCleared = this.board.clearLinesReturnCount();
    const isPerfectClear = (linesCleared > 0) && this.board.isBoardEmpty(); 
    if (this.renderer && this.renderer.stopFlashOverlay) this.renderer.stopFlashOverlay();
    this.applyScoring(linesCleared, tspinType, isPerfectClear);
    if (isPerfectClear) {
      this.renderer.startPCMessage();
    }
    this.lastKick = null;
    this.lastMoveWasTSpin = 'none';
    this.lastAction = null;
    this.createPiece();
    if (this.board.collide(this.currentPiece, this.currentPiecePos)) {
      this.ui.considerUpdateHiRecords(this.score, this.level, this.comboCount, this.btbCount, this.pcCount);
      this.board.reset();
      this.score = 0; this.level = 1; this.linesClearedTotal = 0;
      this.holdPiece = null; this.holdColor = ''; this.holdPieceIndex = -1;
      this.comboCount = 0; this.btbCount = 0; this.backToBack = false;
      this.pcCount = 0;
      if (scoreEl) scoreEl.textContent = `Score: ${this.score}`;
      if (levelEl) levelEl.textContent = `Level: ${this.level}`;
      this.ui.updateComboBtbUI(this.comboCount, this.btbCount);
      this.renderer.drawHold(this.holdPiece, this.holdColor);
      this.createPiece();
    }
  }

  gravityStep() {
    if (!this.currentPiece) return;
    this.currentPiecePos.y++;    if (this.board.collide(this.currentPiece, this.currentPiecePos)) {
      this.currentPiecePos.y--;
      if (this.groundedSince === null) this.groundedSince = performance.now();
    } else this.groundedSince = null;
  }

  predictClearedLines(pos, piece) {
    const px = Math.floor(pos.x);
    const py = Math.floor(pos.y);
    const potentialRows = new Set();
    if (piece._bbox) {
      const top = py + piece._bbox.minY;
      const bottom = py + piece._bbox.maxY;
      const t = Math.max(0, Math.floor(top));
      const b = Math.min(this.board.rows - 1, Math.floor(bottom));
      for (let y = t; y <= b; y++) potentialRows.add(y);
    } else {
      for (let i = 0; i < piece._cells.length; i++) {
        const by = py + piece._cells[i].y;
        if (by >= 0 && by < this.board.rows) potentialRows.add(by);
      }
    }

    let lines = 0;
    const fullMask = this.board.fullMask;
    const simRowBits = new Uint32Array(this.board.rowBits);
    for (let i = 0; i < piece._cells.length; i++) {
      const c = piece._cells[i];
      const bx = px + c.x;
      const by = py + c.y;
      if (by >= 0 && by < this.board.rows && bx >= 0 && bx < this.board.cols) {
        simRowBits[by] |= (1 << bx);
      }
    }
    for (const by of potentialRows) {
      if (simRowBits[by] === fullMask) lines++;
    }
    return lines;
  }

  tryLockIfDue(now) {
    if (!this.currentPiece) return;
    if (this.isGrounded()) {
      if (this.groundedSince === null) this.groundedSince = performance.now();
      now = now || performance.now();
      const predictedCleared = this.predictClearedLines(this.currentPiecePos, this.currentPiece);
      const tspinType = this.detectTSpin(this.lastKick, this.currentPiecePos, this.rotationState, this.currentPieceIndex, predictedCleared);
      let isPerfectClearPredicted = false;
      if (predictedCleared > 0) {
        const tempBoard = new Board(this.board.cols, this.board.rows);
        tempBoard.grid.set(this.board.grid);
        tempBoard.rowBits.set(this.board.rowBits);
        tempBoard.mergePiece(this.currentPiece, this.currentPiecePos, this.currentColor);
        tempBoard.clearLinesReturnCount();
        isPerfectClearPredicted = tempBoard.isBoardEmpty();
      }
      if (tspinType !== 'none' || isPerfectClearPredicted) {
        if (predictedCleared > 0) {
          const lockedCellsArray = [];
          const lockedCellsSet = new Set();
          if (this.currentPiece && this.currentPiece._cells) {
            for (let i = 0; i < this.currentPiece._cells.length; i++) {
              const c = this.currentPiece._cells[i];
              const cx = this.currentPiecePos.x + c.x, cy = this.currentPiecePos.y + c.y;
              lockedCellsArray.push({ x: cx, y: cy });
              lockedCellsSet.add(`${cx},${cy}`);
            }
          } else {
            for (let y = 0; y < 4; y++) for (let x = 0; x < 4; x++) if (this.currentPiece[y] && this.currentPiece[y][x]) {
              const cx = this.currentPiecePos.x + x, cy = this.currentPiecePos.y + y;
              lockedCellsArray.push({ x: cx, y: cy });
              lockedCellsSet.add(`${cx},${cy}`);
            }
          }
          const needsUpdate = tspinType !== this.lastFlashTspinType || predictedCleared !== this.lastFlashPredictedCleared || !setsEqual(lockedCellsSet, this.lastFlashCells) || !this.renderer.flash.active;
          if (needsUpdate) {
            if (this.renderer.flash.active) this.renderer.stopFlashOverlay();
            let flashColor = '#FF8E0D';
            if (isPerfectClearPredicted) {
              flashColor = '#CCCCCC';
            } else if (tspinType === 'mini') {
              flashColor = '#FF8E0D';
            } else if (tspinType === 'full') {
              if (predictedCleared === 1) flashColor = '#FF0D72';
              else if (predictedCleared === 2) flashColor = '#0DC2FF';
              else if (predictedCleared === 3) flashColor = '#FFE138';
            }
            this.renderer.startFlashOverlay(lockedCellsArray, flashColor, isPerfectClearPredicted);
            this.lastFlashTspinType = tspinType;
            this.lastFlashPredictedCleared = predictedCleared;
            this.lastFlashCells = lockedCellsSet;
          }
        } else {
          if (this.renderer.flash.active) this.renderer.stopFlashOverlay();
          this.lastFlashTspinType = 'none';
          this.lastFlashPredictedCleared = 0;
          this.lastFlashCells = new Set();
        }
      } else {
        if (this.renderer.flash.active) this.renderer.stopFlashOverlay();
        this.lastFlashTspinType = 'none';
        this.lastFlashPredictedCleared = 0;
        this.lastFlashCells = new Set();
      }
      if ((now || performance.now()) - this.groundedSince >= CONFIG.LOCK_DELAY_MS) { this.lockNow(); this.groundedSince = null; }
    } else {
      this.groundedSince = null;
      if (this.renderer.flash.active) this.renderer.stopFlashOverlay();
      this.lastFlashTspinType = 'none';
      this.lastFlashPredictedCleared = 0;
      this.lastFlashCells = new Set();
    }
  }

  holdCurrentPiece() {
    if (!this.canHold) return;
    if (this.holdPiece === null) {
      this.holdPiece = this.currentPiece;
      this.holdColor = this.currentColor;
      this.holdPieceIndex = this.currentPieceIndex;
      this.createPiece();
    } else {
      const tp = this.currentPiece, tc = this.currentColor, ti = this.currentPieceIndex;
      this.currentPiece = this.holdPiece; this.currentColor = this.holdColor; this.currentPieceIndex = this.holdPieceIndex;
      this.holdPiece = tp; this.holdColor = tc; this.holdPieceIndex = ti;
      this.currentPiecePos = { x: Math.floor(this.cols / 2) - 2, y: 0 };
      this.rotationState = 0; this.groundedSince = null; this.lastKick = null;
      this.pieceSpawnTime = performance.now();
      this.pieceSpawnRotationId = this.rotationIdCounter;
    }
    this.canHold = false;
    this.renderer.drawHold(this.holdPiece, this.holdColor);
  }

  createPiece(initial = false) {
    this.lastAction = null;
    this.randomizer.ensure(this.PREVIEW_COUNT + 1);
    const popped = this.randomizer.pop();
    this.currentPieceIndex = popped;
    this.currentPiece = pieceRotations[this.currentPieceIndex][0];
    this.currentColor = COLORS[this.currentPieceIndex];
    this.randomizer.ensure(this.PREVIEW_COUNT + 1);
    this.currentPiecePos = { x: Math.floor(this.cols / 2) - 2, y: 0 };
    this.rotationState = 0;
    this.groundedSince = null;
    this.canHold = true;
    this.lastKick = null;
    this.pieceSpawnTime = performance.now();
    this.pieceSpawnRotationId = this.rotationIdCounter;
    this.renderer.drawPreview(this.randomizer.queue);
    this.renderer.drawHold(this.holdPiece, this.holdColor);
  }

  setupButtons() {
    this.input.makeRepeatButton(document.getElementById('btn-left'), () => {
      const oldX = this.currentPiecePos.x;
      this.currentPiecePos.x--;
      if (this.board.collide(this.currentPiece, this.currentPiecePos)) {
        this.currentPiecePos.x++;
      } else if (this.currentPieceIndex === 2) {
        this.lastAction = 'move_horizontal';
      }
      if (!this.isGrounded()) this.groundedSince = null;
    });
    this.input.makeRepeatButton(document.getElementById('btn-right'), () => {
      const oldX = this.currentPiecePos.x;
      this.currentPiecePos.x++;
      if (this.board.collide(this.currentPiece, this.currentPiecePos)) {
        this.currentPiecePos.x--;
      } else if (this.currentPieceIndex === 2) {
        this.lastAction = 'move_horizontal';
      }
      if (!this.isGrounded()) this.groundedSince = null;
    });
    this.input.makeRepeatButton(document.getElementById('btn-soft'), () => {
      const oldY = this.currentPiecePos.y;
      this.currentPiecePos.y++;
      if (this.board.collide(this.currentPiece, this.currentPiecePos)) {
        this.currentPiecePos.y--;
      }else if (this.currentPieceIndex === 2) {
        this.lastAction = 'move_vertical';
    }
      if (!this.isGrounded()) this.groundedSince = null;
    });
    this.input.makeShortPressButton(document.getElementById('btn-hard'), () => {
      if (!this.currentPiece) return;
      const g = this.getGhostPosition();
      this.currentPiecePos = g;
      this.lockNow();
    });
    this.input.instantButton(document.getElementById('btn-rot-cw'), () => { this.tryRotateWithKicks(1); this.renderer.drawPreview(this.randomizer.queue); });
    this.input.instantButton(document.getElementById('btn-rot-ccw'), () => { this.tryRotateWithKicks(-1); this.renderer.drawPreview(this.randomizer.queue); });
    this.input.makeShortPressButton(document.getElementById('btn-hold'), () => { this.holdCurrentPiece(); this.renderer.drawPreview(this.randomizer.queue); });
    
  }

  update(time = 0) {
    const now = time || performance.now();
    const dt = now - this.lastTime;
    this.lastTime = now;
    this.dropCounter += dt;
    const dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);
    if (this.dropCounter > dropInterval) { this.gravityStep(); this.dropCounter = 0; }
    this.tryLockIfDue(now);

    let animColorHex = this.currentColor;
    let ghostColorStr = this.currentColor + '33';
    const baseHex = this.currentColor || COLORS[this.currentPieceIndex];
    const entry = AnimCache.ensure(baseHex, CONFIG.ANIM_CYCLE_MS, CONFIG.ANIM_BUCKETS);
    const idx = Math.floor((now % entry.cycleMs) * entry.invCycle);
    animColorHex = entry.hexs[idx];
    ghostColorStr = entry.rgas[idx];

    this.renderer.draw(now, this.currentPiece, this.currentPiecePos, this.currentColor, animColorHex, ghostColorStr);
    this.renderer.drawPreview(this.randomizer.queue);
    this._rafId = requestAnimationFrame(this._boundUpdate);
  }
}

  function setsEqual(a, b) {
    if (a.size !== b.size) return false;
    for (const v of a) if (!b.has(v)) return false;
    return true;
  }


  (function startGame() {
    const game = new Game();
    window._tetrisGame = game;
  })();
  })();
  </script>
</body>
</html>